---
import Layout from '../layouts/Layout.astro';
import vertexShaderSource from '../shaders/vertex.glsl?raw';
import fragmentShaderSource from '../shaders/fragment.glsl?raw';
---

<Layout>
	<div id="container">
		<canvas id="glCanvas"></canvas>
		<button id="menuToggle" aria-label="Toggle menu">
			<span></span>
			<span></span>
			<span></span>
		</button>
		<div id="controls" class="collapsed">
			<h1>Magic Mirror</h1>
			<div class="control-group">
				<label>
					Effect:
					<select id="effectSelector">
						<option value="-1" selected>Cycle (all effects)</option>
						<option value="0">Glitch</option>
						<option value="1">Smear</option>
						<option value="2">Projector</option>
						<option value="3">Unlock</option>
						<option value="4">Wobble</option>
						<option value="5">Posterize</option>
						<option value="6">Quicksilver</option>
						<option value="7">Twist</option>
						<option value="8">Smolder</option>
						<option value="9">Blur</option>
						<option value="10">Rainbow</option>
						<option value="11">Smoke</option>
					</select>
				</label>
			</div>
			<div class="control-group">
				<label>
					Effect Strength:
					<input type="range" id="effectStrength" min="0" max="100" value="30" />
					<span id="strengthValue">30</span>
				</label>
			</div>
			<div class="control-group">
				<label>
					Effect Speed:
					<input type="range" id="effectSpeed" min="0" max="100" value="50" />
					<span id="speedValue">50</span>
				</label>
			</div>
		</div>
	</div>
</Layout>

<style>
	#container {
		width: 100%;
		height: 100vh;
		display: flex;
		justify-content: center;
		align-items: center;
		background: #000;
		position: relative;
	}

	#glCanvas {
		width: 100%;
		height: 100%;
		display: block;
	}

	#menuToggle {
		position: absolute;
		top: 20px;
		right: 20px;
		width: 50px;
		height: 50px;
		background: rgba(0, 0, 0, 0.7);
		border: none;
		border-radius: 10px;
		cursor: pointer;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		gap: 6px;
		z-index: 1001;
		transition: background 0.3s ease;
	}

	#menuToggle:hover {
		background: rgba(0, 0, 0, 0.85);
	}

	#menuToggle span {
		width: 30px;
		height: 3px;
		background: white;
		border-radius: 2px;
		transition: all 0.3s ease;
	}

	#controls {
		position: absolute;
		top: 20px;
		right: 20px;
		background: rgba(0, 0, 0, 0.7);
		padding: 20px;
		border-radius: 10px;
		color: white;
		font-family: Arial, sans-serif;
		min-width: 250px;
		transition: transform 0.3s ease, opacity 0.3s ease;
		z-index: 1000;
	}

	#controls.collapsed {
		transform: translateX(calc(100% + 20px));
		opacity: 0;
		pointer-events: none;
	}

	h1 {
		margin: 0 0 20px 0;
		font-size: 24px;
		text-align: center;
	}

	.control-group {
		margin-bottom: 15px;
	}

	label {
		display: block;
		font-size: 14px;
		margin-bottom: 5px;
	}

	select {
		padding: 5px;
		background: rgba(255, 255, 255, 0.1);
		color: white;
		border: 1px solid rgba(255, 255, 255, 0.3);
		border-radius: 5px;
		font-size: 14px;
		cursor: pointer;
		margin-left: 10px;
	}

	select option {
		background: #333;
		color: white;
	}

	input[type="range"] {
		width: 150px;
		margin: 0 10px;
	}

	span {
		display: inline-block;
		width: 30px;
		text-align: right;
	}
</style>

<script define:vars={{ vertexShaderSource, fragmentShaderSource }}>
	// Compile shader
	function createShader(gl, type, source) {
		const shader = gl.createShader(type);
		if (!shader) return null;
		
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			return null;
		}
		
		return shader;
	}

	// Create shader program
	function createProgram(gl, vertexShader, fragmentShader) {
		const program = gl.createProgram();
		if (!program) return null;
		
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error('Program linking error:', gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
			return null;
		}
		
		return program;
	}

	// Initialize WebGL
	function initWebGL() {
		const canvas = document.getElementById('glCanvas');
		const gl = canvas.getContext('webgl');
		
		if (!gl) {
			alert('WebGL not supported');
			return;
		}

		// Create video element (declared early so resizeCanvas can reference it)
		const video = document.createElement('video');
		video.setAttribute('autoplay', 'true');
		video.setAttribute('playsinline', 'true');

		// Set canvas size to window size
		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			gl.viewport(0, 0, canvas.width, canvas.height);
			// Update texture coords when canvas resizes (if video is loaded)
			if (video && video.videoWidth > 0) {
				updateTexCoords(video.videoWidth, video.videoHeight, canvas.width, canvas.height);
			}
		}
		resizeCanvas();
		window.addEventListener('resize', resizeCanvas);

		// Create shaders
		const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
		const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
		
		if (!vertexShader || !fragmentShader) {
			console.error('Failed to create shaders');
			return;
		}

		// Create program
		const program = createProgram(gl, vertexShader, fragmentShader);
		if (!program) {
			console.error('Failed to create program');
			return;
		}

	// Look up attribute and uniform locations
	const positionLocation = gl.getAttribLocation(program, 'a_position');
	const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
	const textureLocation = gl.getUniformLocation(program, 'u_texture');
	const timeLocation = gl.getUniformLocation(program, 'u_time');
	const effectStrengthLocation = gl.getUniformLocation(program, 'u_effectStrength');
	const effectSpeedLocation = gl.getUniformLocation(program, 'u_effectSpeed');
	const effectIdLocation = gl.getUniformLocation(program, 'u_effectId');

		// Create position buffer (full screen quad)
		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1,
			 1, -1,
			-1,  1,
			-1,  1,
			 1, -1,
			 1,  1,
		]), gl.STATIC_DRAW);

		// Create texture coordinate buffer (flipped horizontally for mirror effect)
		const texCoordBuffer = gl.createBuffer();
		
		// Initialize with default mirrored coords
		gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			1, 1,
			0, 1,
			1, 0,
			1, 0,
			0, 1,
			0, 0,
		]), gl.STATIC_DRAW);
		
		// Function to update texture coordinates based on aspect ratios (for cropping)
		function updateTexCoords(videoWidth, videoHeight, canvasWidth, canvasHeight) {
			const videoAspect = videoWidth / videoHeight;
			const canvasAspect = canvasWidth / canvasHeight;
			
			let u0 = 0, u1 = 1, v0 = 0, v1 = 1;
			
			if (canvasAspect > videoAspect) {
				// Canvas is wider - crop top/bottom of video
				const scale = canvasAspect / videoAspect;
				const offset = (1 - 1 / scale) / 2;
				v0 = offset;
				v1 = 1 - offset;
			} else {
				// Canvas is taller - crop left/right of video
				const scale = videoAspect / canvasAspect;
				const offset = (1 - 1 / scale) / 2;
				u0 = offset;
				u1 = 1 - offset;
			}
			
			// Apply texture coords (flip horizontally for mirror by swapping u0/u1)
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				u1, v1,  // bottom-right -> bottom-left (flipped)
				u0, v1,  // bottom-left -> bottom-right (flipped)
				u1, v0,  // top-right -> top-left (flipped)
				u1, v0,  // top-right -> top-left (flipped)
				u0, v1,  // bottom-left -> bottom-right (flipped)
				u0, v0,  // top-left -> top-right (flipped)
			]), gl.STATIC_DRAW);
		}

		// Create texture
		const texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		// Get webcam stream
		navigator.mediaDevices.getUserMedia({ video: true, audio: false })
			.then(stream => {
				video.srcObject = stream;
				video.play();
				// Update texture coords when video metadata is loaded
				video.addEventListener('loadedmetadata', () => {
					updateTexCoords(video.videoWidth, video.videoHeight, canvas.width, canvas.height);
				});
			})
			.catch(err => {
				console.error('Error accessing webcam:', err);
				alert('Could not access webcam. Please grant camera permissions.');
			});

	// Control panel toggle
	const menuToggle = document.getElementById('menuToggle');
	const controls = document.getElementById('controls');
	
	menuToggle.addEventListener('click', () => {
		controls.classList.toggle('collapsed');
	});

	// Close menu when clicking outside
	document.addEventListener('click', (e) => {
		if (!controls.contains(e.target) && !menuToggle.contains(e.target)) {
			controls.classList.add('collapsed');
		}
	});

	// Control values
	let effectId = -1.0; // Default to Cycle (all effects)
	let effectStrength = 30;
	let effectSpeed = 50;

	// Set up control listeners
	const effectSelector = document.getElementById('effectSelector');
	const effectStrengthInput = document.getElementById('effectStrength');
	const effectSpeedInput = document.getElementById('effectSpeed');
	const strengthValue = document.getElementById('strengthValue');
	const speedValue = document.getElementById('speedValue');

	effectSelector.addEventListener('change', (e) => {
		effectId = parseFloat(e.target.value);
	});

	effectStrengthInput.addEventListener('input', (e) => {
		effectStrength = parseInt(e.target.value);
		if (strengthValue) strengthValue.textContent = effectStrength.toString();
	});

	effectSpeedInput.addEventListener('input', (e) => {
		effectSpeed = parseInt(e.target.value);
		if (speedValue) speedValue.textContent = effectSpeed.toString();
	});

		// Render loop
		let startTime = Date.now();
		function render() {
			const currentTime = (Date.now() - startTime) / 1000;

			// Update texture with video frame
			if (video.readyState >= video.HAVE_CURRENT_DATA) {
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
			}

			// Clear canvas
			gl.clearColor(0, 0, 0, 1);
			gl.clear(gl.COLOR_BUFFER_BIT);

			// Use program
			gl.useProgram(program);

		// Set uniforms
		gl.uniform1i(textureLocation, 0);
		gl.uniform1f(timeLocation, currentTime);
		gl.uniform1f(effectStrengthLocation, effectStrength);
		gl.uniform1f(effectSpeedLocation, effectSpeed);
		gl.uniform1f(effectIdLocation, effectId);

			// Set position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.enableVertexAttribArray(positionLocation);
			gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

			// Set texture coordinate attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.enableVertexAttribArray(texCoordLocation);
			gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

			// Draw
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			requestAnimationFrame(render);
		}

		render();
	}

	// Start when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initWebGL);
	} else {
		initWebGL();
	}
</script>
