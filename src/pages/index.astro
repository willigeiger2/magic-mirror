---
import Layout from '../layouts/Layout.astro';
import vertexShaderSource from '../shaders/vertex.glsl?raw';
import fragmentShaderSource from '../shaders/fragment.glsl?raw';
---

<Layout>
	<div id="container">
		<canvas id="glCanvas"></canvas>
		<div id="controls">
			<h1>Magic Mirror</h1>
			<div class="control-group">
				<label>
					Distortion Amount:
					<input type="range" id="distortionAmount" min="0" max="100" value="30" />
					<span id="distortionValue">30</span>
				</label>
			</div>
			<div class="control-group">
				<label>
					Distortion Speed:
					<input type="range" id="distortionSpeed" min="0" max="100" value="50" />
					<span id="speedValue">50</span>
				</label>
			</div>
			<div class="control-group">
				<label>
					Color Shift:
					<input type="range" id="colorShift" min="0" max="100" value="20" />
					<span id="colorValue">20</span>
				</label>
			</div>
		</div>
	</div>
</Layout>

<style>
	#container {
		width: 100%;
		height: 100vh;
		display: flex;
		justify-content: center;
		align-items: center;
		background: #000;
		position: relative;
	}

	#glCanvas {
		width: 100%;
		height: 100%;
		display: block;
	}

	#controls {
		position: absolute;
		top: 20px;
		right: 20px;
		background: rgba(0, 0, 0, 0.7);
		padding: 20px;
		border-radius: 10px;
		color: white;
		font-family: Arial, sans-serif;
		min-width: 250px;
	}

	h1 {
		margin: 0 0 20px 0;
		font-size: 24px;
		text-align: center;
	}

	.control-group {
		margin-bottom: 15px;
	}

	label {
		display: block;
		font-size: 14px;
		margin-bottom: 5px;
	}

	input[type="range"] {
		width: 150px;
		margin: 0 10px;
	}

	span {
		display: inline-block;
		width: 30px;
		text-align: right;
	}
</style>

<script define:vars={{ vertexShaderSource, fragmentShaderSource }}>
	// Compile shader
	function createShader(gl, type, source) {
		const shader = gl.createShader(type);
		if (!shader) return null;
		
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			return null;
		}
		
		return shader;
	}

	// Create shader program
	function createProgram(gl, vertexShader, fragmentShader) {
		const program = gl.createProgram();
		if (!program) return null;
		
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error('Program linking error:', gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
			return null;
		}
		
		return program;
	}

	// Initialize WebGL
	function initWebGL() {
		const canvas = document.getElementById('glCanvas');
		const gl = canvas.getContext('webgl');
		
		if (!gl) {
			alert('WebGL not supported');
			return;
		}

		// Create video element (declared early so resizeCanvas can reference it)
		const video = document.createElement('video');
		video.setAttribute('autoplay', 'true');
		video.setAttribute('playsinline', 'true');

		// Set canvas size to window size
		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			gl.viewport(0, 0, canvas.width, canvas.height);
			// Update texture coords when canvas resizes (if video is loaded)
			if (video && video.videoWidth > 0) {
				updateTexCoords(video.videoWidth, video.videoHeight, canvas.width, canvas.height);
			}
		}
		resizeCanvas();
		window.addEventListener('resize', resizeCanvas);

		// Create shaders
		const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
		const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
		
		if (!vertexShader || !fragmentShader) {
			console.error('Failed to create shaders');
			return;
		}

		// Create program
		const program = createProgram(gl, vertexShader, fragmentShader);
		if (!program) {
			console.error('Failed to create program');
			return;
		}

		// Look up attribute and uniform locations
		const positionLocation = gl.getAttribLocation(program, 'a_position');
		const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
		const textureLocation = gl.getUniformLocation(program, 'u_texture');
		const timeLocation = gl.getUniformLocation(program, 'u_time');
		const distortionAmountLocation = gl.getUniformLocation(program, 'u_distortionAmount');
		const distortionSpeedLocation = gl.getUniformLocation(program, 'u_distortionSpeed');
		const colorShiftLocation = gl.getUniformLocation(program, 'u_colorShift');

		// Create position buffer (full screen quad)
		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1,
			 1, -1,
			-1,  1,
			-1,  1,
			 1, -1,
			 1,  1,
		]), gl.STATIC_DRAW);

		// Create texture coordinate buffer (flipped horizontally for mirror effect)
		const texCoordBuffer = gl.createBuffer();
		
		// Initialize with default mirrored coords
		gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			1, 1,
			0, 1,
			1, 0,
			1, 0,
			0, 1,
			0, 0,
		]), gl.STATIC_DRAW);
		
		// Function to update texture coordinates based on aspect ratios (for cropping)
		function updateTexCoords(videoWidth, videoHeight, canvasWidth, canvasHeight) {
			const videoAspect = videoWidth / videoHeight;
			const canvasAspect = canvasWidth / canvasHeight;
			
			let u0 = 0, u1 = 1, v0 = 0, v1 = 1;
			
			if (canvasAspect > videoAspect) {
				// Canvas is wider - crop top/bottom of video
				const scale = canvasAspect / videoAspect;
				const offset = (1 - 1 / scale) / 2;
				v0 = offset;
				v1 = 1 - offset;
			} else {
				// Canvas is taller - crop left/right of video
				const scale = videoAspect / canvasAspect;
				const offset = (1 - 1 / scale) / 2;
				u0 = offset;
				u1 = 1 - offset;
			}
			
			// Apply texture coords (flip horizontally for mirror by swapping u0/u1)
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				u1, v1,  // bottom-right -> bottom-left (flipped)
				u0, v1,  // bottom-left -> bottom-right (flipped)
				u1, v0,  // top-right -> top-left (flipped)
				u1, v0,  // top-right -> top-left (flipped)
				u0, v1,  // bottom-left -> bottom-right (flipped)
				u0, v0,  // top-left -> top-right (flipped)
			]), gl.STATIC_DRAW);
		}

		// Create texture
		const texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		// Get webcam stream
		navigator.mediaDevices.getUserMedia({ video: true, audio: false })
			.then(stream => {
				video.srcObject = stream;
				video.play();
				// Update texture coords when video metadata is loaded
				video.addEventListener('loadedmetadata', () => {
					updateTexCoords(video.videoWidth, video.videoHeight, canvas.width, canvas.height);
				});
			})
			.catch(err => {
				console.error('Error accessing webcam:', err);
				alert('Could not access webcam. Please grant camera permissions.');
			});

		// Control values
		let distortionAmount = 30;
		let distortionSpeed = 50;
		let colorShift = 20;

		// Set up control listeners
		const distortionAmountInput = document.getElementById('distortionAmount');
		const distortionSpeedInput = document.getElementById('distortionSpeed');
		const colorShiftInput = document.getElementById('colorShift');
		const distortionValue = document.getElementById('distortionValue');
		const speedValue = document.getElementById('speedValue');
		const colorValue = document.getElementById('colorValue');

		distortionAmountInput.addEventListener('input', (e) => {
			distortionAmount = parseInt(e.target.value);
			if (distortionValue) distortionValue.textContent = distortionAmount.toString();
		});

		distortionSpeedInput.addEventListener('input', (e) => {
			distortionSpeed = parseInt(e.target.value);
			if (speedValue) speedValue.textContent = distortionSpeed.toString();
		});

		colorShiftInput.addEventListener('input', (e) => {
			colorShift = parseInt(e.target.value);
			if (colorValue) colorValue.textContent = colorShift.toString();
		});

		// Render loop
		let startTime = Date.now();
		function render() {
			const currentTime = (Date.now() - startTime) / 1000;

			// Update texture with video frame
			if (video.readyState >= video.HAVE_CURRENT_DATA) {
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
			}

			// Clear canvas
			gl.clearColor(0, 0, 0, 1);
			gl.clear(gl.COLOR_BUFFER_BIT);

			// Use program
			gl.useProgram(program);

			// Set uniforms
			gl.uniform1i(textureLocation, 0);
			gl.uniform1f(timeLocation, currentTime);
			gl.uniform1f(distortionAmountLocation, distortionAmount);
			gl.uniform1f(distortionSpeedLocation, distortionSpeed);
			gl.uniform1f(colorShiftLocation, colorShift);

			// Set position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.enableVertexAttribArray(positionLocation);
			gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

			// Set texture coordinate attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.enableVertexAttribArray(texCoordLocation);
			gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

			// Draw
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			requestAnimationFrame(render);
		}

		render();
	}

	// Start when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initWebGL);
	} else {
		initWebGL();
	}
</script>
